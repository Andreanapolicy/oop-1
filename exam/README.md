- [Целочисленные типы данных](#целочисленные-типы-данных)
- [Типы данных вещественных чисел](#типы-данных-вещественных-чисел)
- [Логический тип данных](#логический-тип-данных)
- [Символьные литералы](#символьные-литералы)
- [Строковые литералы](#строковые-литералы)
- [Переменные](#переменные)
- [Синонимы типов](#синонимы-типов)
- [Перечислимый тип данных](#перечислимый-тип-данных)
- [Приведение типа](#приведение-типа)
- [Управление ходом выполнения программы](#управление-ходом-выполнения-программы)
- [Структуры](#структуры)
- [Массивы](#массивы)
- [Ссылки](#ссылки)
- [Пространства имён](#пространства-имён)
- [std::string и std::string\_view](#stdstring-и-stdstring_view)
- [std::vector](#stdvector)
- [std::deque](#stddeque)
- [std::list и std::forward\_list](#stdlist-и-stdforward_list)
- [Контейнеры map и multimap](#контейнеры-map-и-multimap)
- [Контейнеры unordered\_map и unordered\_multimap](#контейнеры-unordered_map-и-unordered_multimap)
- [Контейнеры set и multiset](#контейнеры-set-и-multiset)
- [Контейнеры unordered\_set и unordered\_multiset](#контейнеры-unordered_set-и-unordered_multiset)



## Целочисленные типы данных
1. Каковы основные типы целых чисел в C++?
2. Как объявить переменную целого типа в C++?
3. Каковы диапазоны значений для различных типов целых чисел в C++?
4. Каковы основные операции, которые можно выполнять с целыми числами в C++?
5. Каковы правила преобразования типов при выполнении операций с целыми числами в C++?
6. Какие битовые операции можно использовать для работы с целыми числами в C++? Привести примеры
7. Как проверить, является ли целое число четным или нечетным в C++?
8. Как вычислить остаток от деления двух целых чисел в C++? Чему
9. Как проверить, является ли целое число положительным или отрицательным в C++?
10. Как использовать условные операторы и циклы для работы с целыми числами в C++?

## Типы данных вещественных чисел
1. Какие типы вещественных чисел существуют в C++?
2. Как объявить переменную вещественного типа в C++?
3. Каковы диапазоны значений для различных типов вещественных чисел в C++?
4. Какие операции можно выполнять с вещественными числами в C++?
5. Как происходит преобразование типов при выполнении операций с вещественными числами в C++?
6. Какие математические функции доступны в C++ для работы с вещественными числами?
7. Как проверить, является ли вещественное число положительным или отрицательным в C++?
8. Как проверить, является ли вещественное число целым в C++?
9. Как округлить вещественное число до целого в C++?
10. Как сравнить два вещественных числа на равенство в C++?

## Логический тип данных
1. Какой тип данных используется для хранения логических значений в C++?
2. Какие значения может принимать логический тип в C++?
3. Как объявить переменную логического типа в C++?
4. Какие операторы сравнения могут использоваться с логическим типом в C++?
5. Какие логические операторы доступны в C++?
6. Какой результат выражения true && false в C++?
7. Какой результат выражения true || false в C++?
8. Какой результат выражения !true в C++?
9. Какой результат выражения (5 > 3) && (7 < 10) в C++?
10. Какой результат выражения (4 == 4) || (6 != 6) в C++?

## Символьные литералы
1. Какие символьные литералы поддерживаются в языке С++?
2. Что такое символьный литерал, и как он объявляется в С++?
3. Какие символьные значения можно задать с помощью символьных литералов в С++?
4. Какой символьный литерал используется для обозначения перевода строки в С++?
5. Может ли символьный литерал содержать несколько символов? Если да, то как это делается?
6. Что такое управляющие последовательности символов, и какие из них поддерживаются в С++?
7. Приведите не менее 3 примеров символьных литералов в С++?
8. Какие символьные литералы используются для обозначения специальных символов, таких как пробел или знак табуляции?

## Строковые литералы
1. Как объявляется строковый литерал в языке C++?
2. Что такое управляющие последовательности символов и как они используются в строковых литералах в языке C++?
3. Каким образом можно задать пустую строку в языке C++?
4. Каким образом можно скомбинировать два строковых литерала в одну строку в языке C++?
5. Как строковые литералы представляются в памяти?
6. Строковые литералы и для чего они нужны. Как использовать сырые строковые литералы
7. Чем отличаются эти строковые литералы: `L"Hello"` от `"Hello"`?

## Переменные
1. Объявление переменных
2. Автоматическое определение типа переменной
3. Объявление константной переменной.
4. Области видимости переменных.
5. Доступ к переменной, объявленной в другое единице трансляции.

## Синонимы типов
1. Что такое синоним типа в языке C++ и для чего он используется?
2. Каким образом объявляются синонимы типов в языке C++?
3. Объявите синоним типов с помощью `using`.
4. Как объявить синоним типа для стандартных типов данных, таких как int или double, в языке C++?
5. Как объявить синоним типа для пользовательского типа данных в языке C++?
6. Какие преимущества имеет использование синонимов типов в языке C++?
7. Каким образом можно определить новый тип данных с использованием `typedef` в языке C++?=

## Перечислимый тип данных
1. Что такое перечислимый тип данных в языке C++ и для чего он используется?
2. Как объявляется перечислимый тип данных в языке C++?
3. Чем отличается перечислимый тип данных от обычных целочисленных типов данных в языке C++?
4. Какие значения могут принимать элементы перечислимого типа данных в языке C++?
5. Каким образом можно указать базовый тип данных для перечисляющего типа данных в языке C++?
6. Что такое scoped enum в языке C++ и как он отличается от обычного перечислимого типа данных?
7. Как объявляется scoped enum в языке C++?
8. Как можно обратиться к элементу scoped enum в языке C++?
9. Что такое underlying type у scoped enum в языке C++ и как он используется?
10. Какие преимущества имеет использование scoped enum в языке C++ перед обычным перечислимым типом данных?


## Приведение типа
1. Что такое приведение типа (typecasting) в языке C++ и для чего оно нужно?
2. Что такое явное приведение типа (explicit typecasting) и каким оператором оно осуществляется в языке C++?
3. Что такое неявное приведение типа (implicit typecasting) и как оно происходит в языке C++?
4. Приведите пример неявного приведение типа в языке C++?
5. Приведение типа в стиле языка C.
6. Какие операторы приведения типов есть в языке C++ и для чего они нужны?


## Управление ходом выполнения программы
1. Выражения, инструкции, блоки
2. Оператор if. Конструкция else if.
3. `if constexpr`
4. Оператор цикла `for`. Цикл со счётчиком.
5. range-based for. Что нужно сделать, чтобы элементы контейнера можно было перебирать, используя range-based for? 
6. Оператор цикла `while`.
7. Оператор цикла `do-while`.
8. Досрочный выход из цикла и пропуск итерации цикла.
9. Оператор множественного выбора switch-case.
10. Атрибут `[[fallthrough]]`.

## Структуры
1. Для чего нужны структуры?
2. Как объявить структуру?
3. Что такое член структуры и как им можно управлять?
4. Способы инициализации структур?
5. Как обратиться к полю структуры?
6. Как передать структуру в функцию в C++, и какие способы можно использовать для передачи структуры?
7. Указатель на структуру, как обратиться к полю структуры по указателю?
8. Массивы структур.
9. Размещение полей структур в памяти.

## Массивы
1. Как объявить массив в C++?
2. Что такое индекс массива?
3. Как получить доступ к элементу массива по индексу?
4. Как узнать размер массива?
5. Можно ли изменить размер массива после его создания?
6. Как заполнить массив значениями по умолчанию?
7. Как отсортировать элементы массива в порядке возрастания?
8. Что общего у строковых литералов и массивов символов?
9. Что такое std::array и как оно отличается от обычного массива?
10. Объявление многомерных массивов. Объявление многомерного массива с помощью `std::array`

## Ссылки
1. Что такое ссылка, как она объявляется?
2. Константные ссылки.
3. Передача параметров в функцию по значению, по ссылке, по константной ссылке.
4. Особенности ссылкой на временные объекты.

## Пространства имён
1. Что такое пространство имён?
2. Как объявить пространство имён в C++?
3. Можно ли использовать несколько пространств имён в одном файле?
4. Каким образом происходит разрешение конфликтов имен в разных пространствах имён?
5. Какие стандартные пространства имён существуют в C++?
6. Можно ли создавать свои собственные пространства имён?
7. Каким образом можно использовать элементы из других пространств имён?
8. Что такое алиасы (синонимы) пространства имён и как их объявлять?
9. Какой синтаксис используется при обращении к элементам вложенных пространств имён?
10. Безымянное пространство имён. Как его объявить, для чего отличается?

## std::string и std::string_view
1. Класс std::string.
2. Какого внутреннее устройство std::string в типичных реализациях?
3. Какие операции можно выполнять над std::string?
4. Что такое small string optimization?
5. Какова сложность операций вставки и замены символов строки?
6. Класс std::string_view, чем отличается от std::string?
7. В каких случаях использовать std::string_view, а в каких std::string?
9. Чем отличается substr в std::string и std::string_view?
10. Как найти все вхождения некоторой подстроки в строке?
11. Как быстро найти все вхождения некоторой подстроки в строке?
12. Как преобразовать std::string в числовой тип данных и обратно?
13. Как можно ускорить работу со строками в C++?

## std::vector
1. Что такое std::vector? Чем отличается от массива и std::array?
2. Описать внутреннее устройство std::vector.
3. Типичные операции над std::vector. Какая сложность этих операций?
4. Приёмы оптимизации производительности при работе с std::vector.
5. Метод at и операция []. Чем отличаются, когда что использовать?
6. Обход элементов вектора в прямом и обратном порядке
7. Как обойти все элементы std::vector в прямом и обратном направлении?
8. Чем размер вектора отличается от его вместимости?
9.  Что такое инвалидация итераторов? Какие операции над std::vector приводят к инвалидации его итераторов?
10. Чем отличаются emplace-методы от push/insert?
11. Идиома erase/remove
12. Как развернуть содержимое std::vector за O(1) памяти и O(N) времени?
13. Как вставить в вектор элементы из другого контейнера (в конец, в начало, в середину). Какова сложность этих операций?

## std::deque
1. Контейнер std::deque. Чем отличается от std::vector, в каких случаях применять vector, а в каких deque?
2. Какие операции над std::deque приводят к инвалидации итераторов 
3. Основные операции над std::deque и их сложность.
4. Чем отличаются emplace-методы от push/insert
5. Отличия std::deque от std::list. Когда лучше применять deque, а когда list?
6. Какие операции над std::deque приводят к инвалидации ссылок?
7. Как развернуть std::deque?
8. Как вставить в deque элементы из другого контейнера (в начало, в конец, в середину) 

## std::list и std::forward_list
1. Контейнер std::list и std::forward_list, чем отличаются? Когда использовать list, а когда forward_list?
2. Какие операции поддерживает std::list, а какие std::forward_list?
3. Какие операции над list и forward_list приводят к инвалидации ссылок и итераторов, а какие нет? Почему?
4. Как развернуть std::forward_list?
5. Как отсортировать std::list? Какова сложность этой операции?
6. Как перенести элементы из одного списка в другой? Какова сложность этих операций?
7. Как удалить элементы std::list, удовлетворяющие заданному критерию?
8. Как удалить из std::list подряд идущие дубликаты? `[1, 3, 2, 2, -8, 5, 1, 1, 1, 2]` -> `[1, 3, 2, -8, 5, 1, 2]`
9. Как перенести элементы из одного forward_list в другой. Какова сложность этих операций?
10. Как отсортировать всё содержимое forward_list?
11. Как отсортировать диапазон элементов std::list и std::forward_list?


## Контейнеры map и multimap
1. Контейнер std::map. Для чего используется?
2. Операции над map. Какова сложность этих операций?
3. В каком порядке находятся элементы std::map? Можно ли изменить порядок элементов? Если да, то как?
4. Могут ли в качестве ключей map использоваться пользовательские типы данных? Что для этого нужно сделать?
5. Каким требованиям должен удовлетворять тип данных, использующийся в качестве значений?
6. Чем отличается вставка элементов c помощью `map[key] = value` от вставки `map.emplace(key, value)`?
7. Чем отличается вставка элементов c помощью `map[key] = value` от вставки `map.at(key) = value`?
8. Напишите функцию `optional<string> TryGetValue(const map<int, string>& m, int key)`
9. Как можно ускорить вставку в map?
10. Как быстро перенести элемент из одного контейнера map в другой map того же типа?
11. Как получить все значения multimap с заданным ключом?
12. В каких случаях использовать map, а в каких unordered_map?
13. Чем отличается emplace от try_emplace?
14. В каком порядке возможен обход элементов контейнера map?
15. Как удалить из контейнера map все элементы, удовлетворяющие заданному критерию? Как удалить из контейнера map не более N элементов, удовлетворяющих заданному критерию?

## Контейнеры unordered_map и unordered_multimap
1. Контейнер unordered_map. Для чего используется?
2. Операции над unordered_map. Их сложность.
3. Что означает "амортизированная константа" применительно к сложности операций?
4. В каком порядке хранятся элементы внутри unordered_map? Можно ли изменить порядок этих элементов?
5. Как можно ускорить вставку в unordered_map?
6. Чем отличается вставка элементов c помощью `umap[key] = value` от вставки `umap.emplace(key, value)`?
7. Чем отличается вставка элементов c помощью `umap[key] = value` от вставки `umap.at(key) = value`?
8. Напишите функцию `optional<string> TryGetValue(const unordered_map<int, string>& m, int key)`.
9. Что нужно сделать, чтобы в качестве ключей unordered_map использовать пользовательские типы данных?
10. Что такое хеш-функция? Как она используется в unordered_map?
11. Как быстро перенести элемент из одного unordered_map в другой того же типа
12. Что такое bucket-ы в unordered_map? Как они влияют на производительность?
13. Что такое rehashing? Когда он возникает? Как можно им управлять?
14. Контейнер unordered_multimap. Чем отличается от unordered_map?
15. Как получить все элементы unordered_map с одним и тем же ключом?
16. В каком порядке возможен обход элементов unordered_map?
17. Когда использовать map, а когда unordered_map?
18. Как удалить из unordered_map не более N элементов, удовлетворяющих заданному критерию?


## Контейнеры set и multiset
1. Контейнер std::set. Для чего используется?
2. Операции над set. Какова сложность этих операций?
3. В каком порядке находятся элементы std::set? Можно ли изменить порядок элементов? Если да, то как?
4. Могут ли в качестве элементов set использоваться пользовательские типы данных? Если да, то что для этого нужно сделать?
5. Каким требованиям должен удовлетворять тип данных, использующийся в качестве элементов set?
6. Чем отличается вставке через insert от вставки через emplace? Когда какой метод использовать?
7. Как быстро перенести один элемент из одного контейнера set в другой того же типа?
8. Когда использовать set, а когда unordered_set?
9. Как можно ускорить вставку в set?
10. Как скопировать элементы из vector в set? Как скопировать элементы из set в vector?
11. Контейнер multiset. Как получить все значения контейнера multiset с заданным ключом?
12. Чем отличается insert от emplace?
13. Как удалить из set все элементы, удовлетворяющие заданному критерию? Как удалить из set не более N элементов, удовлетворяющих заданному критерию?


## Контейнеры unordered_set и unordered_multiset
1. Контейнер std::unordered_set. Для чего используется?
2. Операции над unordered_set. Какова сложность этих операций?
3. В каком порядке находятся элементы std::unordered_set? Можно ли изменить порядок элементов? Если да, то как?
4. Могут ли в качестве элементов unordered_set использоваться пользовательские типы данных? Если да, то что для этого нужно сделать?
5. Каким требованиям должен удовлетворять тип данных, использующийся в качестве элементов unordered_set?
6. Чем отличается вставке через insert от вставки через emplace? Когда какой метод использовать?
7. Как быстро перенести один элемент из одного контейнера unordered_set в другой того же типа?
8. Когда использовать set, а когда unordered_set?
9.  Как скопировать элементы из vector в unordered_set? Как скопировать элементы из unordered_set в vector?
10. Контейнер unordered_multiset. Как получить все значения контейнера unordered_multiset с заданным ключом?
11. Как удалить из unordered_set все элементы, удовлетворяющие заданному критерию? Как удалить из unordered_set не более N элементов, удовлетворяющих заданному критерию?
10. Что такое хеш-функция? Как она используется в unordered_set?
12. Что такое bucket-ы в unordered_set? Как они влияют на производительность?
13. Что такое rehashing? Когда он возникает? Как можно им управлять?

